#!/usr/bin/env python3
'''
This file creates MK Landscapes based on command line configuration,
and outputs them to a directory of your choice. For a listing
of functionality, run ./make_mk.py --help
'''
import random
import math
import sys
from os import path


######## These are the function row creators ############
def trap(k):
    '''
    Creates a 'trap' function row where the optimum is all 1s
    but all other solutions are improved by having fewer 1s.
    '''
    one_count = [sum(map(int, bin(i)[2:])) for i in range(1<<k)]
    trapped = [k - u - 1 if k != u else u for u in one_count]
    return trapped

def nkq(k):
    ''' Creates an NKq function row where q = 2^k. '''
    q = 1 << k
    return [random.randrange(0, q) for _ in range(1 << k)]

def sat(k):
    ''' Creates a MAX-kSAT function row (a 3 variable clause). '''
    line = [1] * (1 << k)
    index = random.randrange(len(line))
    line[index] = 0
    return line

def spinglass(k):
    ''' Creates a 2D spin glass function row. Fails if k != 2. '''
    assert(k == 2)
    # Edge is either -1 or +1.
    options = [[1, -1, -1, 1], [-1, 1, 1, -1]]
    return random.choice(options)

##### These are the variable interaction creators ##########

def separate(n, k):
    ''' Creates n/k non-overlapping subsets of size k. '''
    ordering = list(range(n))
    random.shuffle(ordering)
    lines = []
    for i in range(0, n, k):
        lines.append([ordering[i + j] for j in range(k)])
    return lines

def adjacent(n, k):
    '''
    Creates n subsets of size k such that "adjacent" subsets overlap
    in all but 1 variable.
    '''
    lines = []
    ordering = list(range(n))
    random.shuffle(ordering)
    for i in range(n):
        lines.append([ordering[(i + j) % n] for j in range(k)])
    return lines

def unrestricted(n, k):
    '''
    Creates n subsets of size k such that the ith subset must
    include the ith variable and (k-1) other variables.
    '''
    choices = list(range(n))
    lines = []
    for i in range(n):
        random.shuffle(choices)
        line = [i]
        for x in choices:
            if len(line) == k:
                break
            if x != i:
                line.append(x)
        lines.append(line)
    return lines

def repeated_unrestricted(n, k, ratio=4.27):
    '''
    Creates n * ratio subsets of size k
    '''
    choices = list(range(n))
    lines = []
    for i in range(int(ratio * n)):
        lines.append(random.sample(choices, k))
    return lines

def mesh(n, _):
    '''
    Creates 2n subsets of size 2 such that each subset
    corresponds to an edge in a 2D mesh
    '''
    ordering = list(range(n))
    random.shuffle(ordering)
    width = int(math.sqrt(n))
    lines = []
    for y in range(width):
        row_start = y * width
        for x in range(width):
            v1 = ordering[row_start + x]
            v2 = ordering[row_start + ((x + 1) % width)]
            v3 = ordering[x + (row_start + width) % n]
            lines.append([v1, v2])
            lines.append([v1, v3])
    return lines

####### General Tools ##################

def output_mk(n, k, variable_maker, fitness_line_maker, out=sys.stdout):
    '''
    Given all parameters needed to construct an MK Landscape,
    output it to the specified file using DIMACS format
    '''
    lines = variable_maker(n, k)
    print('c This file generated by make_mk.py, written by Brian Goldman', file=out)
    print('c For questions please contact brianwgoldman@acm.org', file=out)
    print('c Variables chosen using:', variable_maker.__name__, file=out)
    print('c Fitnesses generated using:', fitness_line_maker.__name__, file=out)
    print("p MK", n, len(lines), file=out)
    for line in lines:
        print('m', ' '.join(map(str, line)), file=out)
        fitnesses = fitness_line_maker(k)
        print(' '.join(map(str, fitnesses)), file=out)

# Lookup table of problems to their function creators / subset generators
standard_problems = {
                     "AdjacentNKq" : (adjacent, nkq),
                     "RandomNKq" : (unrestricted, nkq),
                     "MAXSAT" : (repeated_unrestricted, sat),
                     "IsingSpinGlass" : (mesh, spinglass),
                     "DeceptiveTrap" : (separate, trap),
                     }

def create(folder, problem_name, N, K, seed):
    '''
    Open file based on the MK Landscapes parameters, and then write to it.
    '''
    random.seed(seed)
    filename = problem_name + "_{}_{}_{}.txt".format(N, K, seed)
    filename = path.join(folder, filename)
    problem = standard_problems[problem_name]
    with open(filename, "w") as f:
        output_mk(N, K, problem[0], problem[1], f)

if __name__ == '__main__':
    import argparse
    from os import makedirs
    parser = argparse.ArgumentParser(description="MK Landscape generator")
    parser.add_argument('-folder', dest='folder', type=str, default="mk_instances",
                        help='Name to use when creating the output folder')
    parser.add_argument('-seed', dest='seed', type=int, default=None,
                        help='Seed for the random number generator')
    parser.add_argument('-n', dest='N', type=int, default=30,
                        help='Number of bits in the problem')
    parser.add_argument('-k', dest='K', type=int, default=2,
                        help='The maximum number of variables which can appear in one subfunction')
    parser.add_argument('-problem', dest='problem', type=str, default="AdjacentNKq",
                        help='Which problem to use, options are: ' + ', '.join(sorted(standard_problems.keys())))

    args = parser.parse_args()
    try:
        # Ensure the proper folder structure exists
        makedirs(args.folder)
    except OSError:
        pass
    if args.problem not in standard_problems.keys():
        # This interface requires the use of standard problems
        print("Invalid problem:", args.problem, file=sys.stderr)
        sys.exit()
    if args.seed is None:
        # If no seed is specified, use a random 32 bit integer
        args.seed = random.randint(0, (1 << 32) - 1)
    create(args.folder, args.problem, args.N, args.K, args.seed)
